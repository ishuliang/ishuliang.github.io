[{"content":" 美食 外滩 三件套 朋友 我 上海欢迎你 武康大楼 三件套 我 上海 东方明珠 红色记忆 红色记忆 红色记忆 红色记忆 红色记忆 红色记忆 ","date":"2025-05-05T22:00:00Z","image":"https://shuliang-blog.oss-cn-hangzhou.aliyuncs.com/%E4%B8%8A%E6%B5%B7%E4%B8%89%E6%97%A5%E6%B8%B8/index.JPG","permalink":"https://liushuliang.github.io/blog/%E4%B8%8A%E6%B5%B7%E4%B8%89%E6%97%A5%E6%B8%B8/","title":"上海三日游"},{"content":"问题\r我今天执行一个方法，该方法有@Transactional(rollbackFor = Exception.class),方法执行没有报错，在返回之后提交事务，会执行到private native int socketRead0(FileDescriptor fd, byte b[], int off, int len, int timeout)阻塞起来，程序无法进行，接口报错超时。\n解决办法：\r我重启了MySQL服务，就正常了，治标不治本。\n猜测：\r到提交这里阻塞，而且重启MySQL就恢复正常了，应该是MySQL服务中有事务阻塞了。\n下次遇见应该查一下MySQL的阻塞事务，具体看一下是什么原因，这次没找到原因所以没机会复现了，记录一下，便于下次排查纠错。\n最终结果\r数据库没存储空间了\n","date":"2025-03-06T17:38:48Z","image":"https://liushuliang.github.io/blog/2025030617/index_hu_2dc995f21feaa004.jpg","permalink":"https://liushuliang.github.io/blog/2025030617/","title":"MySQL事务执行卡住"},{"content":"如何把一个时间字符串转为数据库中datetime类型\rMySQL中不存在TO_DATE(str,format)方法，但是可以使用STR_TO_DATE(str,format)方法：\n1 STR_TO_DATE ( \u0026#39;2025-02-27 06:59:59\u0026#39;, \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39; ) Oracle中就可以直接用TO_DATE(str,format)方法，但是format需要注意一下，是不一样的：\n1 TO_DATE( \u0026#39;2025-02-27 06:59:59\u0026#39;, \u0026#39;yyyy-MM-dd hh24:mi:ss\u0026#39; ) ","date":"2025-02-27T09:59:16Z","image":"https://liushuliang.github.io/blog/mysql%E5%92%8Coracdatetime/index_hu_fae69bc092ac6fdc.jpg","permalink":"https://liushuliang.github.io/blog/mysql%E5%92%8Coracdatetime/","title":"MySQL和Oracdatetime"},{"content":"记一次使用BiConsumer记录\r遇到的问题\r在对接HL7中过程中遇到了一段代码，非常繁琐，想找找优化代码的方案，询问了ChatGPT，回答了这个接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 switch (type) { case \u0026#34;IMP\u0026#34;: pacsPO.setImpression(this.getHl7Value(data)); break; case \u0026#34;REC\u0026#34;: pacsPO.setAdvice(this.getHl7Value(data)); break; case \u0026#34;GDT\u0026#34;: pacsPO.setSee(this.getHl7Value(data)); break; case \u0026#34;RRP\u0026#34;: pacsPO.setReportUrl(this.getHl7Value(data)); break; case \u0026#34;ZMF\u0026#34;: pacsPO.setMasterReportFile(this.getHl7Value(data)); break; case \u0026#34;ZRF\u0026#34;: pacsPO.setRelationReportFile(this.getHl7Value(data)); break; case \u0026#34;AFD\u0026#34;: pacsPO.setObserValue(this.getHl7Value(data)); break; case \u0026#34;ANT\u0026#34;: break; case \u0026#34;I9\u0026#34;: pacsPO.setDiagName(this.getHl7Value(data)); break; case \u0026#34;CMR\u0026#34;: continue; default: continue; } 大体特征是每个类型对应一个set方法。\n优化方案\r先初始化这个map，放进去一个方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * typeHandlerMap用于存放对应类型所应该字段的赋值 **/ private static Map\u0026lt;String, BiConsumer\u0026lt;PatientPacsResultPO, Type\u0026gt;\u0026gt; typeHandlerMap = new HashMap\u0026lt;\u0026gt;(); /** * 初始化typeHandlerMap * 2025/2/20 9:52 **/ static { typeHandlerMap.put(\u0026#34;IMP\u0026#34;, (po, data) -\u0026gt; po.setImpression(getHl7Value(data))); typeHandlerMap.put(\u0026#34;GDT\u0026#34;, (po, data) -\u0026gt; po.setSee(getHl7Value(data))); typeHandlerMap.put(\u0026#34;REC\u0026#34;, (po, data) -\u0026gt; po.setAdvice(getHl7Value(data))); typeHandlerMap.put(\u0026#34;RRP\u0026#34;, (po, data) -\u0026gt; po.setReportUrl(getHl7Value(data))); typeHandlerMap.put(\u0026#34;ZMF\u0026#34;, (po, data) -\u0026gt; po.setMasterReportFile(getHl7Value(data))); typeHandlerMap.put(\u0026#34;ZRF\u0026#34;, (po, data) -\u0026gt; po.setRelationReportFile(getHl7Value(data))); typeHandlerMap.put(\u0026#34;AFD\u0026#34;, (po, data) -\u0026gt; po.setObserValue(getHl7Value(data))); typeHandlerMap.put(\u0026#34;I9\u0026#34;, (po, data) -\u0026gt; po.setDiagName(getHl7Value(data))); } 然后方法中调用\n1 2 typeHandlerMap.getOrDefault(type, (po, d) -\u0026gt; { }).accept(pacsPO, data); ","date":"2025-02-20T15:17:11+08:00","image":"https://liushuliang.github.io/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8biconsumer%E8%AE%B0%E5%BD%95/index_hu_f4c4b7cf88b1d822.JPG","permalink":"https://liushuliang.github.io/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8biconsumer%E8%AE%B0%E5%BD%95/","title":"记一次使用BiConsumer记录"},{"content":"mybatis多数据源问题\r配置\r参考网站（https://baomidou.com/guides/dynamic-datasource/）\n还有原理解析的一个参考网站（https://www.cnblogs.com/fnlingnzb-learner/p/16805784.html）\n问题\r我在远程调用时，直接引入service层（再mapper层上写了@DS），调用saveOrUpdateBatch，自带的方法，多数据源没有生效，我在这个远程调用的方法上加@DS，就生效了。\n猜测\r@DS用的切面，我直接使用serviceImpl类自带的实现类中方法，这些方法走的SqlSession，并没有走到mybatis的mapper层，所以并没有切面调用切换数据源，还是走的默认数据源。\nTODO 空闲时间，研究一下这个问题\r","date":"2025-02-11T11:27:26Z","image":"https://liushuliang.github.io/blog/mybatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%97%AE%E9%A2%98/index_hu_d56c47ce9f4eca59.jpg","permalink":"https://liushuliang.github.io/blog/mybatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%97%AE%E9%A2%98/","title":"mybatis多数据源问题"},{"content":"摩尔投票一般用于找绝对众数。在数列p中出现次数严格大于p/2的数就是绝对众数。\n可以使用map统计每个数字出现次数\n使用排序，取中间数字\n摩尔投票的思想：\n每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。（在一定存在的条件下）\n具体实现可以参考：https://www.cnblogs.com/RioTian/p/12486239.html\n","date":"2024-12-16T10:18:53Z","image":"https://liushuliang.github.io/blog/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/index_hu_9158b8021377d654.jpg","permalink":"https://liushuliang.github.io/blog/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/","title":"摩尔投票"},{"content":"异或、与、或都是按位运算。\r或运算有两种情况会导致结果为true，分别是：1. 都为true；2. 一个为true，一个为false。为了区分这种情况引入了异或^，这样或的第一种全相同则为false，而不同则为true，也就是说异或主要用于判断两个值是否为不同\n异或运算规律\r由于相同为0，不同为1.\n所以：\n一个值与自己的异或总为false 一个值与0的异或总为这个数 可交换性、可结合性 异或应用方面\r简化计算 我们可以先找相同的异或得到0在计算其他的。\n交换值 两个变量连续三次异或就可以互换值。\nx, y\n第一次：x1 = x ^ y\n第二次：y1 = x1 ^ y = x ^ y ^ y = x\n第三次：x2 = x1 ^ y1 = x ^ y ^ x = y\n现在x2 = y; y1 = x。\n加密、数据备份 参考ruanyf的博客吧（https://www.ruanyifeng.com/blog/2021/01/_xor.html）\n想到异或的原因\r在豆包上看到一个题目，然后就看了一些别人的写法，觉得不错，记录一下。\n原题是这样的：\n在一个班级中，每位同学都拿到了一张卡片，上面有一个整数。有趣的是，除了一个数字之外，所有的数字都恰好出现了两次。现在需要你帮助班长小C快速找到那个拿了独特数字卡片的同学手上的数字是什么。\n输入：cards = [1, 1, 2, 2, 3, 3, 4, 5, 5],输出4，因为4是唯一一个没有配对的\n输入：cards = [0, 1, 0, 1, 2]，输出2，因为2是唯一一个没有配对的\n约束条件： 数字大小为奇数，重复数字只会出现两次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Main { public static int solution(int[] cards) { // Edit your code here int result = 0; for (int card : cards) { result ^= card; } return result; } public static void main(String[] args) { // Add your test cases here System.out.println(solution(new int[]{1, 1, 2, 2, 3, 3, 4, 5, 5}) == 4); System.out.println(solution(new int[]{0, 1, 0, 1, 2}) == 2); } } 这里用的就是异或的运算，所有的异或之后，因为重复的数字只会出现两次，所以重复数字计算会为0，单独一个就剩下来了，就输出来了。\n","date":"2024-11-13T15:04:30Z","image":"https://liushuliang.github.io/blog/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E6%89%BE%E5%8D%95%E7%8B%AC%E7%9A%84%E6%95%B0/index_hu_eb0edece3f98a75d.jpg","permalink":"https://liushuliang.github.io/blog/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E6%89%BE%E5%8D%95%E7%8B%AC%E7%9A%84%E6%95%B0/","title":"异或运算——找单独的数"},{"content":"背景\r在使用MyBatis根据时间范围动态SQL拼接查询数据库时报错：Caused by: Caused by: org.xml.sax.SAXParseException: The content of elements must consist of well-formed character data or markup.（元素内容必须由格式正确的字符数据或标记组成。）\n解决办法\rMyBatis 在编写动态SQL的时候，是基于OGNL的。\n不改变符号，依然使用 “ \u0026gt; ” 或者 “ \u0026lt; ” ，则需要使用 OGNL 标签，将该符号包起来，可以是包裹单个符号，也可以将整句包裹寄来，示例SQL如下： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;select id=\u0026#34;getLoginLogByPage\u0026#34; resultType=\u0026#34;com.mcp.entity.LoginLog\u0026#34;\u0026gt; SELECT l.id, l.job_number, l.name, l.createDate, l.ip_addr , l.remark FROM loginlog l \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;jobNumber != null\u0026#34; \u0026gt; \u0026lt;![CDATA[ and l.job_number \u0026gt; #{jobNumber}]]\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; GROUP BY l.today_date, l.ip_address; \u0026lt;/select\u0026gt; 使用 OGNL 语法表达式，在 OGNL 语法表达式中不能直接写符号，需要要使用其转义后的字符，对应如下： 符号 转义字符 说明 \u0026lt; \u0026amp;lt; 小于 \u0026lt;= \u0026amp;lt;= 小于等于 \u0026gt; \u0026amp;gt; 大于 \u0026gt;= \u0026amp;gt;= 大于等于 \u0026amp; \u0026amp;amp; 逻辑与 \u0026lsquo;xxx\u0026rsquo; \u0026amp;apos; 单引号 \u0026ldquo;xxx\u0026rdquo; \u0026amp;quot; 双引号 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;select id=\u0026#34;getLoginLogByPage\u0026#34; resultType=\u0026#34;com.mcp.entity.LoginLog\u0026#34;\u0026gt; SELECT l.id, l.job_number, l.name, l.createDate, l.ip_addr , l.remark FROM loginlog l \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;jobNumber != null\u0026#34; \u0026gt; and l.job_number \u0026amp;gt; #{jobNumber} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; GROUP BY l.today_date, l.ip_address; \u0026lt;/select\u0026gt; 参考的这篇文章：https://blog.csdn.net/Hello_World_QWP/article/details/86513179\n","date":"2024-11-07T10:46:34Z","image":"https://liushuliang.github.io/blog/mybatis%E7%9A%84xml%E4%B8%AD%E5%85%83%E7%B4%A0%E6%A0%BC%E5%BC%8F/index_hu_70588d40ae2e079d.jpg","permalink":"https://liushuliang.github.io/blog/mybatis%E7%9A%84xml%E4%B8%AD%E5%85%83%E7%B4%A0%E6%A0%BC%E5%BC%8F/","title":"MyBatis的XML中元素格式"},{"content":" feat: 新功能（feature）\nfix: 修补bug\ndocs: 文档（documentation）\nstyle: 格式（不影响代码运行的变动）\nrefactor: 重构（即不是新增功能，也不是修改bug的代码变动）\nchore: 构建过程或辅助工具的变动\nrevert: 撤销，版本回退\nperf: 性能优化\ntest：测试\nimprovement: 改进\nbuild: 打包\nci: 持续集成\n","date":"2024-11-07T15:17:11+08:00","image":"https://liushuliang.github.io/blog/git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/index_hu_ec3b6a7bcd93f072.jpg","permalink":"https://liushuliang.github.io/blog/git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/","title":"Git提交规范"},{"content":" 在工作中，使用netty来开发遇到了两个问题记录一下\n启动问题\r如果直接注册到容器中启动，如下代码所示，那么Netty会阻塞springboot，导致服务并未完全启动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package top.tangyh.lamp.msg.his.netty; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Component; import javax.annotation.Resource; import java.net.InetSocketAddress; /** * @author 刘书良 * @date 2024年10月12日 14:02 * @describe */ @Component @Slf4j public class NettyServerStart implements ApplicationRunner { private static String HOST = \u0026#34;127.0.0.1\u0026#34;; private static Integer PORT = 8848; @Resource private NettyServer nettyServer; @Override public void run(ApplicationArguments args) throws Exception { InetSocketAddress address = new InetSocketAddress(HOST, PORT); log.info(\u0026#34;neety服务器启动地址: \u0026#34; + HOST + \u0026#34;:\u0026#34; + PORT); nettyServer.start(address); } } 解决办法就是异步处理，在启动方法添加注解@Async，并且在Spring Boot启动类上开启异步注解，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @Override @Async public void run(ApplicationArguments args) throws Exception { InetSocketAddress address = new InetSocketAddress(HOST, PORT); log.info(\u0026#34;neety服务器启动地址: \u0026#34; + HOST + \u0026#34;:\u0026#34; + PORT); nettyServer.start(address); } ------------------------------------- @SpringBootApplication @EnableDiscoveryClient @EnableTransactionManagement @ComponentScan({ UTIL_PACKAGE, BUSINESS_PACKAGE }) @EnableFeignClients(value = { UTIL_PACKAGE, BUSINESS_PACKAGE }) @Slf4j @EnableFormValidator @EnableAsync public class MsgServerApplication { public static void main(String[] args) throws UnknownHostException { ConfigurableApplicationContext application = SpringApplication.run(MsgServerApplication.class, args); Environment env = application.getEnvironment(); log.info(\u0026#34;\\n----------------------------------------------------------\\n\\t\u0026#34; + \u0026#34;应用 \u0026#39;{}\u0026#39; 运行成功! 访问连接:\\n\\t\u0026#34; + \u0026#34;Swagger文档: \\t\\thttp://{}:{}/doc.html\\n\\t\u0026#34; + \u0026#34;数据库监控: \\t\\thttp://{}:{}/druid\\n\u0026#34; + \u0026#34;----------------------------------------------------------\u0026#34;, env.getProperty(\u0026#34;spring.application.name\u0026#34;), InetAddress.getLocalHost().getHostAddress(), env.getProperty(\u0026#34;server.port\u0026#34;, \u0026#34;8080\u0026#34;), InetAddress.getLocalHost().getHostAddress(), env.getProperty(\u0026#34;server.port\u0026#34;, \u0026#34;8080\u0026#34;) ); } } 依赖加载问题\r在netty的handler类中无法注入依赖，这是因为初始化netty时，handler是new出来的没有托管给spring，所以无法依赖注入。\n解决办法是：\n1️⃣加@Component\n1 2 3 @Slf4j @Component public class NettyServerHandler extends ChannelInboundHandlerAdapter 2️⃣创建静态的handler静态对象\n1 private static NettyServerHandler nettyServerHandler; 3️⃣使用@PostConstruct初始化\n1 2 3 4 @PostConstruct public void init() { nettyServerHandler = this; } 在使用时需要在依赖注入前加上handle\n1 nettyServerHandler.icuObsvRdClient.saveXt(recordDTO); ","date":"2024-10-12T15:28:46Z","image":"https://liushuliang.github.io/blog/springboot%E5%92%8Cnetty%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/index_hu_1f8475bcaa0a4040.jpg","permalink":"https://liushuliang.github.io/blog/springboot%E5%92%8Cnetty%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"SpringBoot和Netty遇到的问题"},{"content":"在IDEA中配置\r修改启动脚本\r使用第一步得到的脚本：-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 改造启动脚本命令：\n1 2 3 nohup java \\ -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=50055 \\ -jar remote-debug-0.0.1-SNAPSHOT.jar \u0026amp; 注意在windows中用 ^ 来进行换行\n可以开始调试了\r","date":"2024-07-26T09:40:03Z","image":"https://liushuliang.github.io/blog/idea%E8%BF%9C%E7%A8%8Bdebug%E8%B0%83%E8%AF%95/index_hu_62abe28ae2444da9.jpg","permalink":"https://liushuliang.github.io/blog/idea%E8%BF%9C%E7%A8%8Bdebug%E8%B0%83%E8%AF%95/","title":"IDEA远程DEBUG调试"},{"content":"lombok链式编程；可以一直点set方法\r1 2 3 4 5 new PatientPacsApplyPO() .setPatientIdent(patientIdent) .setHospitalNumber(hospitalNumber) .setGender(gender) .setPatientName(patientName); 要实现上述代码可以添加注解@Accessors(chain = true)\n","date":"2024-07-26T09:40:03Z","image":"https://liushuliang.github.io/blog/lombok%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B/index_hu_3ad7b533b46cd634.jpg","permalink":"https://liushuliang.github.io/blog/lombok%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B/","title":"lombok链式编程"},{"content":"MyBatis多参数传递 四种情况需要加@Param\r方法有多个参数，需要使用@Param注解。 当需要给参数取别名时，需要使用@Param注解。 XML中的SQL使用了$,参数中也需要使用@Param。 动态 SQL ，如果在动态 SQL 中使用了参数作为变量，那么也需要 @Param 注解，即使你只有一个参数。 1 2 3 4 5 6 7 8 9 10 11 //mapper 接口 List\u0026lt;Device\u0026gt; getDeviceListTest(@Param(\u0026#34;deviceId\u0026#34;) String deviceId); \u0026lt;!--mybatis的xml--\u0026gt; \u0026lt;select id=\u0026#34;getDeviceListTest\u0026#34; parameterType=\u0026#34;String\u0026#34; resultType=\u0026#34;Device\u0026#34;\u0026gt; select * from t_device \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;deviceId != null and deviceId != \u0026#39;\u0026#39;\u0026#34;\u0026gt; device_id=#{deviceId} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 为什么有时候不加@Param可以正常运行\r是因为编译的问题，有时候接口通过编译，参数名称发生了变化，所以会报错找不到该参数，有时候又可以正常运行是因为idea编译采用了强制保持方法参数变量明\n参考文章，这篇解释的详细一点：https://blog.csdn.net/neusoft2016/article/details/110818507\n","date":"2024-07-26T09:40:03Z","image":"https://liushuliang.github.io/blog/mybatis%E7%9A%84%E6%B3%A8%E8%A7%A3@param/index_hu_e132815f365d28b2.jpg","permalink":"https://liushuliang.github.io/blog/mybatis%E7%9A%84%E6%B3%A8%E8%A7%A3@param/","title":"Mybatis的注解@Param"},{"content":"常用方法\rObjectUtil.isEmpty()\r比较笼统的判断是否为空，不属于下面类型的仅仅判断是否为null\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static boolean isEmpty(Object obj) { if (null == obj) { return true; } if (obj instanceof CharSequence) { return StrUtil.isEmpty((CharSequence) obj); } else if (obj instanceof Map) { return MapUtil.isEmpty((Map) obj); } else if (obj instanceof Iterable) { return IterUtil.isEmpty((Iterable) obj); } else if (obj instanceof Iterator) { return IterUtil.isEmpty((Iterator) obj); } else if (ArrayUtil.isArray(obj)) { return ArrayUtil.isEmpty(obj); } return false; } Optional.ofNullable().map().orElse()\rv指代是gms这个列表\n1 2 3 4 5 6 List\u0026lt;AllErgenInfoResp\u0026gt; gms = wsAdpterService.getPatientGmInfo(hospitalNumber); patientTagVO.setIsGm( Optional.ofNullable(gms) .map(v -\u0026gt; !v.isEmpty()) .orElse(false) ); equal比较\r使用(\u0026quot;gcx_blood\u0026quot;).equals(param.getObsvCode())而不是param.getObsvCode().equals()\n这样写可以避免空指针异常，如果param.getObsvCode()返回null。调用equal()会抛异常，而使用(\u0026quot;gcx_blood\u0026quot;).equals(null) 不会抛出异常，而是直接返回 false。\nLocalDateTime用法\r格式化输出\r1 2 3 4 5 6 7 8 9 10 11 package cn.hutool.core.date; /** * 格式化日期时间为yyyy-MM-dd HH:mm:ss格式 * * @param time {@link LocalDateTime} * @return 格式化后的字符串 * @since 5.3.11 */ public static String formatNormal(LocalDateTime time) { return format(time, DatePattern.NORM_DATETIME_FORMATTER); } string转LocalDateTime\r1 2 3 4 5 6 7 8 9 10 11 12 /** * 将字符串转为LocalDateTime * * @param dateTimeString * @return java.time.LocalDateTime * @author 刘书良 * 2025/1/9 9:34 **/ public static LocalDateTime stringToLocalDateTime(String dateTimeString) { LocalDateTime localDateTime = LocalDateTimeUtil.parse(dateTimeString, DatePattern.NORM_DATETIME_PATTERN); return localDateTime; } 把map中的值转为list\r1 2 3 4 5 6 7 8 9 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; patientMap = new HashMap\u0026lt;\u0026gt;(); patientMap.put(\u0026#34;patient1\u0026#34;, Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); patientMap.put(\u0026#34;patient2\u0026#34;, Arrays.asList(\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;)); patientMap.put(\u0026#34;patient3\u0026#34;, Arrays.asList(\u0026#34;f\u0026#34;)); // 将所有 values 合并为一个 List List\u0026lt;String\u0026gt; combinedList = patientMap.values().stream() .flatMap(List::stream) // 将每个 List 展开为单个元素的流 .collect(Collectors.toList()); // 收集成一个 List 获取一天的开始和结束时间\r1 2 LocalDateTime startOfDay = LocalDateTime.now().with(LocalTime.MIDNIGHT).minusMinutes(10); LocalDateTime endOfDay = LocalDateTime.now().with(LocalTime.MAX); ","date":"2024-07-23T17:20:49Z","image":"https://liushuliang.github.io/blog/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/index_hu_f78b2c608b7adf02.jpg","permalink":"https://liushuliang.github.io/blog/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81/","title":"Java常用工具类代码"},{"content":"final关键字\r基本用法\r修饰类\r当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。\n报错信息： 无法继承最终的“mianshi.People”\n修饰方法\r下面这段话摘自《Java编程思想》第四版第143页：\n“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“\n因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。\n注：类的private方法会隐式地被指定为final方法。\n修饰变量\r对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。\n深入理解final关键字\r类的final变量和普通变量有什么区别\r当用final作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。\n变量b被final修饰，因此会被当做编译器常量，所以在使用到b的地方会直接将变量b替换为它的值。而对于变量d的访问却需要在运行时通过链接来进行。不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化。\nint类型在Java中，若果作为类成员声明，不初始化值，会被默认初始化为0；如果作为方法的局部变量来声明，不进行初始化的话 会在编译期报错，无法通过编译。\n被final修饰的引用变量指向的对象内容可变吗\r可变，final修饰对象之后，引用地址不可变。\nfinal和static\rstatic作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test { public static void main(String[] args) { MyClass myClass1 = new MyClass(); MyClass myClass2 = new MyClass(); System.out.println(myClass1.i); System.out.println(myClass1.j); System.out.println(myClass2.i); System.out.println(myClass2.j); } } class MyClass { public final double i = Math.random(); public static double j = Math.random(); } 1 2 3 4 0.06299743342842823 0.6863535193008683 0.2856370702656075 0.6863535193008683 static修饰的变量,又称为类变量,也就是说这个变量是属于类的,类的所有实例共享这个变量,可以直接通过类名.变量名的方式获取,静态变量在内存中只存在一份\nmap和redis缓存区别\r缓存的区别\n缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。\n使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。\n当然如果只是将少量数据保存作为缓存并且没有持久化的需求，那么完全可以用Map做缓存。\n详细的区别：\nRedis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了\nRedis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了\nRedis 可以实现分布式的缓存，Map 只能存在创建它的程序里\nRedis 单点吞吐量能达到10万级，是专业的缓存服务，Map 只是一个普通的对象\nRedis 缓存有过期机制，Map 本身无此功能\nRedis 有丰富的 API，Map 就简单太多了\nJava常量池\rString常量池\r当String类直接赋值时，如果常量池内存在这个字符串，则s1直接指向常量池的地址，若没有，则先在常量池内创建这个字符串对象，s1直接指向常量池这个字符串的内存地址； 当String类使用new实例对象时，首先在堆里创建这个对象，若是常量池内没这个字符串，则也创建一个，然后堆里的对象的value指向常量池内的字符串。\nclass常量池\r运行时常量池\r函数式编程\r@RestController和@Controller区别\r@RestController注解等价于@ResponseBody ＋ @Controller。@RestController和@Controller的共同点是都用来表示Spring某个类是否可以接收HTTP请求，二者区别： @RestController无法返回指定页面，而@Controller可以；前者可以直接返回数据，后者需要@ResponseBody辅助。下面详细分析。\n① 是否可以返回页面\n答：@RestController无法返回指定页面，而@Controller可以。 解析：对于Controller， 如果只是使用@RestController注解，则其方法无法返回指定页面，此时配置的视图解析器 InternalResourceViewResolver不起作用，返回的内容就是 return 里的内容。 如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。\n② 返回内容 如果需要返回JSON，XML或自定义mediaType内容到页面，@RestController自己就可以搞定，这个注解对于返回数据比较方便，因为它会自动将对象实体转换为JSON格式。而@Controller需要在对应的方法加上@ResponseBody注解。\n@Bean和@Component区别\r","date":"2024-07-11T14:15:40Z","image":"https://liushuliang.github.io/blog/%E5%92%B8%E4%BA%A8%E5%9B%BD%E9%99%85%E9%9D%A2%E8%AF%95/home_hu_b479357ea1fe579b.jpg","permalink":"https://liushuliang.github.io/blog/%E5%92%B8%E4%BA%A8%E5%9B%BD%E9%99%85%E9%9D%A2%E8%AF%95/","title":"咸亨国际面试"},{"content":"\n","date":"2024-06-25T21:52:38+08:00","image":"https://liushuliang.github.io/blog/%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC/index_hu_b465b80aa1649704.jpg","permalink":"https://liushuliang.github.io/blog/%E6%AF%95%E4%B8%9A%E5%85%B8%E7%A4%BC/","title":"毕业典礼"}]