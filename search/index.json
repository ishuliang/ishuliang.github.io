[{"content":"面试题 redis是什么 Redis 是完全开源免费的， 遵守BSD协议， 是一个高性能的key-value数据库。\nRedis 与其他key - value缓存产品有以下三个特点：\nRedis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\nRedis 不仅仅支持简单的key-value类型的数据， 同时还提供list，set，zset，hash等数据结构的存 储。\nRedis 支持数据的备份， 即master-slave模式的数据备份。\nRedis 优势:\n性能极高: Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。\n丰富的数据类型 : Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及Ordered Sets 数据类型操 作。\n原子: Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子 性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。\n丰富的特性: Redis 还支持 publish/subscribe, 通知, key 过期等等特性。\nRedis 与其他 key-value 存储的不同：\nRedis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路 径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明， 无需进行额外的抽象。\nRedis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存， 因为 数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构， 在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他 们是紧凑的以追加的方式产生的， 因为他们并不需要进行随机访问。\nredis数据双写 Redis 的数据类型 Redis 支持五种数据类型： string（ 字符串），hash（ 哈希）， list（ 列表）， set（ 集合） 及 sorted set（有序集合）。\nRedis 的持久化机制 Redis 提供两种持久化机制 RDB 和 AOF 机制: RDB（Redis DataBase）持久化方式： 是指用数据集快照的方式（半持久化模式）记录 redis 数据库的所 有键值对,在某个时间点将数据写入一个临时文件， 持久化结束后， 用这个临时文件替换上次持久化的 文件， 达到数据恢复。 优点： 1、只有一个文件 dump.rdb， 方便持久化。\n2、容灾性好， 一个文件可以保存到安全的磁盘。\n3、性能最大化， fork 子进程来完成写操作， 让主进程继续处理命令， 所以是 IO 最大化。使用单独子 进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能\n4、相对于数据集大时， 比AOF 的启动效率更高。 缺点: 1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障， 会发生数据丢 失。所以这种方式更适合数据要求不严谨的时候\nAOF（Append-only file）持久化方式： 是指所有的命令行记录以 redis 命令请求协议的格式（完全持久化存储）保存为 aof 文件。 优点： 1、数据安全， aof 持久化可以配置 appendfsync 属性， 有 always， 每进行一次命令操作就记录到aof 文件中一次。 2、通过 append 模式写文件， 即使中途服务器宕机， 可以通过 redis-check-aof 工具解决数据一致性问题。 3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（ 文件过大时会对命令进行合并重写）， 可以删除其中的某些命令（ 比如误操作的 flushall）) 缺点： 1、AOF 文件比 RDB 文件大， 且恢复速度慢。 2、数据集大的时候， 比 rdb 启动效率低。\nredis过期处理 1、定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。 2、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是 否过期， 如果过期的话， 就删除该键;如果没有过期， 就返回该键。 3、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至 于要删除多少过期键， 以及要检查多少个数据库， 则由算法决定。\nredis事务处理 通过 MULTI、EXEC、WATCH 等命令来实现事务功能。支持将多个命令请求打包，按顺序一次性执行，执行期间不会中断处理其他客户端请求，具有原子性（Atomicity)、一致性(Consistency)和隔离性（Isolation），且在特定持久模式下具备持久性（Durability）\nRedis为什么这么快 1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；\n2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；\n3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；\n4、使用多路 I/O 复用模型，非阻塞 IO；\n5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；\nelasticsearch深度分页,怎么解决\nes适合搜索+日志，使用范围很小\n购物车用Redis,redis适合热点数据：频繁访问但不频繁修改 的数据\nredis的数据类型时key-value 类型的\n如果存购物车数据，需要用其中的哈希类型和zset类型\nredis的数据类型中字符串适合存验证码\ncacahe.set(key,value)适用于字符串\n订单存mysql\n在Vue中用try\u0026hellip; catch\u0026hellip;时，只要HTTP状态码不是200就会进入catch，此时获取catch报错的状态码可以用error.response.status\nbytes字节\nencode 编码 将字符串转为字节，decode 解码 及那个字节转为字符串\njson.loads 序列化 把json字符串转为字典\njson.dumps 反序列化\n","date":"2025-07-09T14:56:48+08:00","image":"https://shuliang.asia/p/20250709/f9ffa0e132b8dd7bf0c3c407f27275d_hu_ea61cbcbff40c082.jpg","permalink":"https://shuliang.asia/p/20250709/","title":"Wy面试题"},{"content":"迭代器 使用迭代器遍历删除 1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { List\u0026lt;Integer\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;((int) (100/0.75)); for (int i = 0; i \u0026lt; 100; i++) { arrayList.add(i); } Iterator\u0026lt;Integer\u0026gt; it = arrayList.iterator(); while (it.hasNext()) { Integer next = it.next(); System.out.println(next); it.remove(); } } ","date":"2025-07-08T17:10:00Z","permalink":"https://shuliang.asia/p/20250708/","title":"List迭代器中的modCount"},{"content":"正则表达式 基本匹配 我们想要查找的字符或单词可以直接输入，就像搜索一样。例如，要找出文本中的 curious 一词，只需输入同样的内容。\n任何字符 点.：允许匹配任何字符，包括特殊字符和空格\n字符集[abc] 如果一个词中的字符可以是各种字符，我们就将所有的可选字符写进中括号 [] 中。例如，为了查找文本中的所有单词，我们需要编写表达式，在 [] 中相邻地输入字符 a、e、i、o、u。\n否定字符集[^abc] 为了查找下方文本的所有单词（ber 和bor 除外），请在 [] 中的 ^ 后面并排输入 e 和 o。\n字母范围[a-z] 为了查找指定范围的字母，我们需要将起始字母和结束字母写进 [] 中，中间用连字符-分隔。它区分大小写。请编写表达式，匹配e和o之间所有的小写字母，包括它们本身。\n数字范围[0-9] 为了查找指定范围的数字，我们需要在[]中输入起始和结束数字，中间用连字符-分隔。请编写表达式，匹配3到6之间的所有数字，包括它们本身。\n重复 一些特殊字符用来指定一个字符在文本中重复的次数。它们分别是加号+、星号*和问号?。\n星号* 在字符后面加上*，表示一个字符没有或者存在多次。\n加号+ 在字符后面加上+，表示一个字符出现一次或者多次\n问号? 在字符后面加上+，表示一个字符可选，出现一次或者一次都没有\n大括号-1 用{n}编写表达式，匹配文本中位数为n的字符。\n大括号-2 用{n,}编写表达式，匹配文本中位数至少为n的字符。\n大括号-3 用{n,m}编写表达式，匹配文本中位数为n至m的字符。\n分组 我们可以对一个表达式进行分组，并用这些分组来引用或执行一些规则。\n括号()分组 使用括号包裹字符，实现分组\n引用组 使用\\1来避免重复书写，这里1表示分组顺序。\n非捕获分组 使用括号(?:)分组，确保它不会被引用捕获。\n特殊字符 竖线| 竖线允许一个表达式包含多个不同的分支。所有分支用|分隔。和在字符层面上运作的字符集[abc]不同，分支在表达式层面上运作。\n转义字符\\ 在书写正则表达式时，我们会用到{}[]\\/+*.$^|?这些特殊字符。为了匹配这些特殊字符本身，我们需要使用\\进行转义。\n插入符^ 匹配字符串的开始。如果仅仅需要查找行首字符，就在表达式前面添加^。\n美元符号$ 匹配字符串的结束。加在字符的后面。\n单词字符 \\w 匹配字母、数字、下划线。\n\\W 匹配除字母、数字、下划线之外的字符。\n数字符\\d 仅匹配数字。\n非数字符\\D 匹配除数字外的所有字符。\n空白符\\s 仅匹配空白字符。\n非空白符\\S 匹配除空白符之外的字符。\n零宽断言 如果我们希望正在写的词语出现在另一个词语之前或之后，我们需要使用零宽断言。\n正向先行断言(?=) 为了匹配后面有指定字符的值，我们可以在=后面写。放在字符后\n负向先行断言(?!) 为了匹配后面没有有指定字符的值，我们可以在!后面写。\n正向后行断言(?\u0026lt;=) 为了匹配前面有指定字符的值，我们可以在=后面写。放在字符前\n负向后行断言(?\u0026lt;!) 为了匹配前面没有指定字符的值，我们可以在!后面写。\n标志 标志改变表达式的输出。这就是标志也称为修饰符的原因。标志决定表达式是否将文本视作单独的行处理，是否区分大小写，或者是否查找所有匹配项。\n全局标志g 表达式以//包裹，在后面加g表示匹配全局符合要求的，否则只有一个匹配项。\n多行标志m 正则表达式将所有文本视作一行。但如果我们使用了多行标志，它就会单独处理每一行。\n忽略大小写标志i 为了使我们编写的表达式不再大小写敏感，我们必须启用不区分大小写标志。\n贪婪匹配 正则表达式默认执行贪婪匹配。这意味着匹配内容会尽可能长。\n懒惰匹配 与贪婪匹配不同，懒惰匹配在第一次匹配时停止。\n","date":"2025-06-23T16:39:04+08:00","image":"https://shuliang.asia/p/20250623/20250623_hu_e231f961ecc2781c.jpg","permalink":"https://shuliang.asia/p/20250623/","title":"正则表达式学习"},{"content":" ","date":"2025-06-02T16:18:11+08:00","image":"https://shuliang.asia/p/5%E6%9C%88%E6%B8%B8%E4%B8%8A%E6%B5%B7/4_hu_88d7c68517266492.jpg","permalink":"https://shuliang.asia/p/5%E6%9C%88%E6%B8%B8%E4%B8%8A%E6%B5%B7/","title":"5月游上海"},{"content":"背景 用 leetcode 练习 MySQL 时，使用 where 和 on 进行查询时返回结果不一样。\n实践 定义了两个表 employee、bonus，建表语句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 创建员工表 CREATE TABLE Employee ( empId INT PRIMARY KEY, name VARCHAR(255), supervisor INT, salary INT ); -- 创建奖金表（empId 是 Employee.empId 的外键） CREATE TABLE Bonus ( empId INT PRIMARY KEY, bonus INT, FOREIGN KEY (empId) REFERENCES Employee(empId) ); 插入数据：\n1 2 3 4 5 6 INSERT INTO `leetcode`.`employee` (`empId`, `name`, `supervisor`, `salary`) VALUES (1, \u0026#39;John\u0026#39;, 3, 1000); INSERT INTO `leetcode`.`employee` (`empId`, `name`, `supervisor`, `salary`) VALUES (2, \u0026#39;Dan\u0026#39;, 3, 2000); INSERT INTO `leetcode`.`employee` (`empId`, `name`, `supervisor`, `salary`) VALUES (3, \u0026#39;Brad\u0026#39;, NULL, 4000); INSERT INTO `leetcode`.`employee` (`empId`, `name`, `supervisor`, `salary`) VALUES (4, \u0026#39;Thomas\u0026#39;, 3, 4000); INSERT INTO `leetcode`.`bonus` (`empId`, `bonus`) VALUES (2, 500); INSERT INTO `leetcode`.`bonus` (`empId`, `bonus`) VALUES (4, 2000); 查询奖金低于 1000 的员工 在 on 中写条件查询：\n1 2 3 4 5 6 SELECT * FROM employee AS a LEFT JOIN bonus AS b ON a.empId = b.empId AND b.bonus \u0026lt; 1000 在 where 中写查询条件：\n1 2 3 4 5 SELECT * FROM employee AS a LEFT JOIN bonus AS b ON a.empId = b.empId where b.bonus \u0026lt; 1000 在 where 中会明显少记录。\n查阅资料 我看了一些网上大神写的以及自己总结了一下： on 的条件先进行筛选，对右表进行，然后再进行连接，再使用 where 对连接后的表进行筛选，因此 on 中添加b.bonus \u0026lt; 1000，会先选中 bonus 表中的唯一一条符合的数据，和左边进行笛卡尔积，左表中对不上的直接用 null 补全，所以会有很多 null 数据，而且导致了明明 thomas 的奖金小于 1000 也出现在了结果集中。 where 条件是对笛卡尔积进行筛选的，因此会计算乘积，然后选出其中小于 1000 的数据，但是这样会把那些奖金是 null 的人排除，\n总结 如果想对右表限制就在 on 中添加条件，相应会导致左表在右表中无法匹配到行导致为 null，如果对左边限制就在 where 中添加条件，这样才能过滤掉，而在 on 中添加的限制左表的条件不会生效的，因为 on 只针对关联表也就是右表！ 注意区分左、右连接！！！\n","date":"2025-05-28T16:27:52+08:00","image":"https://shuliang.asia/p/20250528/index_hu_12c93c0b20834ea3.jpg","permalink":"https://shuliang.asia/p/20250528/","title":"Mysql中where和on总结"},{"content":"互斥验证参数 背景 在开发一个查询方式时，需要根据日期查询或者根据开始和结束时间进行范围查询，我一开始的想法时使用 if 进行判断，之后问了 ai，给我提供了一个新思路。\n@AssertTrue 方法 在参数类中定义方法一个方法用于验证，返回类型必须是 Boolean/boolean,访问权限不能为 private，参数为空，方法名最好是 is 开头，便于阅读,下面是我定义的一个互斥校验： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @AssertTrue(message = \u0026#34;输入时间不合法，请检查！\u0026#34;) public boolean isDateOrTimeRangeValid() { boolean hasDate = date != null; boolean hasStart = startTime != null; boolean hasEnd = endTime != null; // 校验互斥逻辑 if (hasDate || (hasStart \u0026amp;\u0026amp; hasEnd)) { // 只要满足要么date不为null，要么start和end同时存在，就返回true if (hasDate) { this.startTime = date.atStartOfDay(); this.endTime = date.atTime(LocalTime.MAX); return true; } else { return startTime.isBefore(endTime); } } return false; } 在开 controller 层开启校验@Valid 1 public R\u0026lt;List\u0026lt;StatsResultVO\u0026gt;\u0026gt; queryStats(@RequestBody @Valid StatsQueryVO vo) 后续待改进 目前这个还是不能自定义返回消息，就是在方法内部设置一个返回消息，表示一个具体信息，只能通过抛出异常的方式来实现。\n","date":"2025-05-27T17:46:31+08:00","image":"https://shuliang.asia/p/20250527/20250527_hu_e34882442398ea9e.jpg","permalink":"https://shuliang.asia/p/20250527/","title":"自定义验证入参方法"},{"content":"mysql 自动自增 起因 今天上午，朋友给我发了一个 sql 语句，然我帮看一下为什么报错，我看到了报错信息：\n第一反应就是主键重复了，但是结果并不是，知道我看了建表语句，发现 id 是auto_increment，我想可能与自增有关，所以我自己建了表查看了一下\n1 2 3 4 5 CREATE TABLE `c_test` ( `id` tinyint(4) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4; 然后手动插入了几条数据\n1 2 INSERT INTO `study`.`c_test` (`id`, `name`) VALUES (0, \u0026#39;0\u0026#39;); INSERT INTO `study`.`c_test` (`id`, `name`) VALUES (1, \u0026#39;1\u0026#39;); 我发现也是报相同的问题，因为不是提交的事务，所以第一句插入成功了，但是 id 确变成了 1，自动递增确实是从 1 开始的，但是现在我指定了 id 为 0，为什么变 1 了呢？\n查询资料并解决 我查了网上的信息，发现说是因为 mysql 自动递增的时候会根据 null 或者 0 来判断是否自增，然后我又去看了一下 mysql 的文档：https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_auto_value_on_zero\n这句话就是说当插入是 0 或者 null 时会自动生成序号，然后我查了一下当前库的sql_mode：\n1 SELECT @@sql_mode 没有改sql_mode值，那确实插入 0 会变 1，导致主键重复。\n","date":"2025-05-19T14:15:19+08:00","image":"https://shuliang.asia/p/20250519/20250519_hu_36beca021bde7108.JPG","permalink":"https://shuliang.asia/p/20250519/","title":"Mysql自动递增"},{"content":"yaml文件中key包含特殊字符 在开发一个单位配置时，我想把他放到nacos上，每次读取配置文件，因为在yaml配置的key中包含特殊字符，比如：+、(、)等等，所以在springboot项目读取到map集合里面时所有的的这些特殊字符莫名消失了，因此导致系统出错了。\n解决办法\n在写key时使用\u0026quot;[]\u0026quot;将key值包起来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 血气分析单位表： unit: map: pH: \u0026#34;\u0026#34; pCO2: \u0026#34;mmHg\u0026#34; pO2: \u0026#34;mmHg\u0026#34; \u0026#34;[K+]\u0026#34;: \u0026#34;mmol/L\u0026#34; \u0026#34;[Na+]\u0026#34;: \u0026#34;mmol/L\u0026#34; \u0026#34;[Ca++]\u0026#34;: \u0026#34;mmol/L\u0026#34; \u0026#34;[Cl-]\u0026#34;: \u0026#34;mmol/L\u0026#34; Glu: \u0026#34;mmol/L\u0026#34; Lac: \u0026#34;mmol/L\u0026#34; tHb: \u0026#34;g/dL\u0026#34; sO2: \u0026#34;%\u0026#34; T: \u0026#34;Cel\u0026#34; FIO2: \u0026#34;%\u0026#34; \u0026#34;[pH(T)]\u0026#34;: \u0026#34;\u0026#34; \u0026#34;[pCO2(T)]\u0026#34;: \u0026#34;mmHg\u0026#34; \u0026#34;[HCO3-]\u0026#34;: \u0026#34;mmol/L\u0026#34; ABE: \u0026#34;mmol/L\u0026#34; SBE: \u0026#34;mmol/L\u0026#34; \u0026#34;[pO2(T)]\u0026#34;: \u0026#34;mmHg\u0026#34; \u0026#34;[p50(act)]\u0026#34;: \u0026#34;mmHg\u0026#34; AaDpO2: \u0026#34;mmHg\u0026#34; tO2: \u0026#34;mmol/L\u0026#34; RI: \u0026#34;%\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 @Data @Component @ConfigurationProperties(prefix = \u0026#34;unit\u0026#34;) public class UnitConfig implements InitializingBean { private Map\u0026lt;String, String\u0026gt; map; @Override public void afterPropertiesSet() throws Exception { System.out.println(map); } } ","date":"2025-05-14T14:40:41+08:00","image":"https://shuliang.asia/p/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/20240514_hu_d23cf31e1eed9d00.jpg","permalink":"https://shuliang.asia/p/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/","title":"配置文件中的特殊字符"},{"content":"问题 我今天执行一个方法，该方法有@Transactional(rollbackFor = Exception.class),方法执行没有报错，在返回之后提交事务，会执行到private native int socketRead0(FileDescriptor fd, byte b[], int off, int len, int timeout)阻塞起来，程序无法进行，接口报错超时。\n解决办法： 我重启了MySQL服务，就正常了，治标不治本。\n猜测： 到提交这里阻塞，而且重启MySQL就恢复正常了，应该是MySQL服务中有事务阻塞了。\n下次遇见应该查一下MySQL的阻塞事务，具体看一下是什么原因，这次没找到原因所以没机会复现了，记录一下，便于下次排查纠错。\n最终结果 数据库没存储空间了\n","date":"2025-03-06T17:38:48Z","image":"https://shuliang.asia/p/20250306/20250306_hu_2dc995f21feaa004.jpg","permalink":"https://shuliang.asia/p/20250306/","title":"MySQL事务执行卡住"},{"content":"如何把一个时间字符串转为数据库中datetime类型 MySQL中不存在TO_DATE(str,format)方法，但是可以使用STR_TO_DATE(str,format)方法：\n1 STR_TO_DATE ( \u0026#39;2025-02-27 06:59:59\u0026#39;, \u0026#39;%Y-%m-%d %H:%i:%s\u0026#39; ) Oracle中就可以直接用TO_DATE(str,format)方法，但是format需要注意一下，是不一样的：\n1 TO_DATE( \u0026#39;2025-02-27 06:59:59\u0026#39;, \u0026#39;yyyy-MM-dd hh24:mi:ss\u0026#39; ) ","date":"2025-02-27T09:59:16Z","image":"https://shuliang.asia/p/20250227/20250227_hu_fae69bc092ac6fdc.jpg","permalink":"https://shuliang.asia/p/20250227/","title":"MySQL和Oracdatetime"},{"content":"记一次使用BiConsumer记录 遇到的问题 在对接HL7中过程中遇到了一段代码，非常繁琐，想找找优化代码的方案，询问了ChatGPT，回答了这个接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 switch (type) { case \u0026#34;IMP\u0026#34;: pacsPO.setImpression(this.getHl7Value(data)); break; case \u0026#34;REC\u0026#34;: pacsPO.setAdvice(this.getHl7Value(data)); break; case \u0026#34;GDT\u0026#34;: pacsPO.setSee(this.getHl7Value(data)); break; case \u0026#34;RRP\u0026#34;: pacsPO.setReportUrl(this.getHl7Value(data)); break; case \u0026#34;ZMF\u0026#34;: pacsPO.setMasterReportFile(this.getHl7Value(data)); break; case \u0026#34;ZRF\u0026#34;: pacsPO.setRelationReportFile(this.getHl7Value(data)); break; case \u0026#34;AFD\u0026#34;: pacsPO.setObserValue(this.getHl7Value(data)); break; case \u0026#34;ANT\u0026#34;: break; case \u0026#34;I9\u0026#34;: pacsPO.setDiagName(this.getHl7Value(data)); break; case \u0026#34;CMR\u0026#34;: continue; default: continue; } 大体特征是每个类型对应一个set方法。\n优化方案 先初始化这个map，放进去一个方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * typeHandlerMap用于存放对应类型所应该字段的赋值 **/ private static Map\u0026lt;String, BiConsumer\u0026lt;PatientPacsResultPO, Type\u0026gt;\u0026gt; typeHandlerMap = new HashMap\u0026lt;\u0026gt;(); /** * 初始化typeHandlerMap * 2025/2/20 9:52 **/ static { typeHandlerMap.put(\u0026#34;IMP\u0026#34;, (po, data) -\u0026gt; po.setImpression(getHl7Value(data))); typeHandlerMap.put(\u0026#34;GDT\u0026#34;, (po, data) -\u0026gt; po.setSee(getHl7Value(data))); typeHandlerMap.put(\u0026#34;REC\u0026#34;, (po, data) -\u0026gt; po.setAdvice(getHl7Value(data))); typeHandlerMap.put(\u0026#34;RRP\u0026#34;, (po, data) -\u0026gt; po.setReportUrl(getHl7Value(data))); typeHandlerMap.put(\u0026#34;ZMF\u0026#34;, (po, data) -\u0026gt; po.setMasterReportFile(getHl7Value(data))); typeHandlerMap.put(\u0026#34;ZRF\u0026#34;, (po, data) -\u0026gt; po.setRelationReportFile(getHl7Value(data))); typeHandlerMap.put(\u0026#34;AFD\u0026#34;, (po, data) -\u0026gt; po.setObserValue(getHl7Value(data))); typeHandlerMap.put(\u0026#34;I9\u0026#34;, (po, data) -\u0026gt; po.setDiagName(getHl7Value(data))); } 然后方法中调用\n1 2 typeHandlerMap.getOrDefault(type, (po, d) -\u0026gt; { }).accept(pacsPO, data); ","date":"2025-02-20T15:17:11+08:00","image":"https://shuliang.asia/p/20250220/20250220_hu_31cd270388739b48.jpg","permalink":"https://shuliang.asia/p/20250220/","title":"记一次使用BiConsumer记录"},{"content":"mybatis多数据源问题 配置 参考网站（https://baomidou.com/guides/dynamic-datasource/）\n还有原理解析的一个参考网站（https://www.cnblogs.com/fnlingnzb-learner/p/16805784.html）\n问题 我在远程调用时，直接引入service层（再mapper层上写了@DS），调用saveOrUpdateBatch，自带的方法，多数据源没有生效，我在这个远程调用的方法上加@DS，就生效了。\n猜测 @DS用的切面，我直接使用serviceImpl类自带的实现类中方法，这些方法走的SqlSession，并没有走到mybatis的mapper层，所以并没有切面调用切换数据源，还是走的默认数据源。\nTODO 空闲时间，研究一下这个问题 ","date":"2025-02-11T11:27:26Z","image":"https://shuliang.asia/p/20250211/20250211_hu_d56c47ce9f4eca59.jpg","permalink":"https://shuliang.asia/p/20250211/","title":"mybatis多数据源问题"},{"content":"摩尔投票一般用于找绝对众数。在数列p中出现次数严格大于p/2的数就是绝对众数。\n可以使用map统计每个数字出现次数\n使用排序，取中间数字\n摩尔投票的思想：\n每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。（在一定存在的条件下）\n具体实现可以参考：https://www.cnblogs.com/RioTian/p/12486239.html\n","date":"2024-12-16T10:18:53Z","image":"https://shuliang.asia/p/20241216/20241216_hu_9158b8021377d654.jpg","permalink":"https://shuliang.asia/p/20241216/","title":"摩尔投票"},{"content":"异或、与、或都是按位运算。 或运算有两种情况会导致结果为true，分别是：1. 都为true；2. 一个为true，一个为false。为了区分这种情况引入了异或^，这样或的第一种全相同则为false，而不同则为true，也就是说异或主要用于判断两个值是否为不同\n异或运算规律 由于相同为0，不同为1.\n所以：\n一个值与自己的异或总为false 一个值与0的异或总为这个数 可交换性、可结合性 异或应用方面 简化计算 我们可以先找相同的异或得到0在计算其他的。\n交换值 两个变量连续三次异或就可以互换值。\nx, y\n第一次：x1 = x ^ y\n第二次：y1 = x1 ^ y = x ^ y ^ y = x\n第三次：x2 = x1 ^ y1 = x ^ y ^ x = y\n现在x2 = y; y1 = x。\n加密、数据备份 参考ruanyf的博客吧（https://www.ruanyifeng.com/blog/2021/01/_xor.html）\n想到异或的原因 在豆包上看到一个题目，然后就看了一些别人的写法，觉得不错，记录一下。\n原题是这样的：\n在一个班级中，每位同学都拿到了一张卡片，上面有一个整数。有趣的是，除了一个数字之外，所有的数字都恰好出现了两次。现在需要你帮助班长小C快速找到那个拿了独特数字卡片的同学手上的数字是什么。\n输入：cards = [1, 1, 2, 2, 3, 3, 4, 5, 5],输出4，因为4是唯一一个没有配对的\n输入：cards = [0, 1, 0, 1, 2]，输出2，因为2是唯一一个没有配对的\n约束条件： 数字大小为奇数，重复数字只会出现两次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Main { public static int solution(int[] cards) { // Edit your code here int result = 0; for (int card : cards) { result ^= card; } return result; } public static void main(String[] args) { // Add your test cases here System.out.println(solution(new int[]{1, 1, 2, 2, 3, 3, 4, 5, 5}) == 4); System.out.println(solution(new int[]{0, 1, 0, 1, 2}) == 2); } } 这里用的就是异或的运算，所有的异或之后，因为重复的数字只会出现两次，所以重复数字计算会为0，单独一个就剩下来了，就输出来了。\n","date":"2024-11-13T15:04:30Z","image":"https://shuliang.asia/p/20241113/20241113_hu_eb0edece3f98a75d.jpg","permalink":"https://shuliang.asia/p/20241113/","title":"异或运算——找单独的数"},{"content":"背景 在使用MyBatis根据时间范围动态SQL拼接查询数据库时报错：Caused by: Caused by: org.xml.sax.SAXParseException: The content of elements must consist of well-formed character data or markup.（元素内容必须由格式正确的字符数据或标记组成。）\n解决办法 MyBatis 在编写动态SQL的时候，是基于OGNL的。\n不改变符号，依然使用 “ \u0026gt; ” 或者 “ \u0026lt; ” ，则需要使用 OGNL 标签，将该符号包起来，可以是包裹单个符号，也可以将整句包裹寄来，示例SQL如下： 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;select id=\u0026#34;getLoginLogByPage\u0026#34; resultType=\u0026#34;com.mcp.entity.LoginLog\u0026#34;\u0026gt; SELECT l.id, l.job_number, l.name, l.createDate, l.ip_addr , l.remark FROM loginlog l \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;jobNumber != null\u0026#34; \u0026gt; \u0026lt;![CDATA[ and l.job_number \u0026gt; #{jobNumber}]]\u0026gt; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; GROUP BY l.today_date, l.ip_address; \u0026lt;/select\u0026gt; 使用 OGNL 语法表达式，在 OGNL 语法表达式中不能直接写符号，需要要使用其转义后的字符，对应如下： 符号 转义字符 说明 \u0026lt; \u0026amp;lt; 小于 \u0026lt;= \u0026amp;lt;= 小于等于 \u0026gt; \u0026amp;gt; 大于 \u0026gt;= \u0026amp;gt;= 大于等于 \u0026amp; \u0026amp;amp; 逻辑与 \u0026lsquo;xxx\u0026rsquo; \u0026amp;apos; 单引号 \u0026ldquo;xxx\u0026rdquo; \u0026amp;quot; 双引号 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;select id=\u0026#34;getLoginLogByPage\u0026#34; resultType=\u0026#34;com.mcp.entity.LoginLog\u0026#34;\u0026gt; SELECT l.id, l.job_number, l.name, l.createDate, l.ip_addr , l.remark FROM loginlog l \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;jobNumber != null\u0026#34; \u0026gt; and l.job_number \u0026amp;gt; #{jobNumber} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; GROUP BY l.today_date, l.ip_address; \u0026lt;/select\u0026gt; 参考的这篇文章：https://blog.csdn.net/Hello_World_QWP/article/details/86513179\n","date":"2024-11-08T10:46:34Z","image":"https://shuliang.asia/p/20241108/20241108_hu_70588d40ae2e079d.jpg","permalink":"https://shuliang.asia/p/20241108/","title":"MyBatis的XML中元素格式"},{"content":" feat: 新功能（feature）\nfix: 修补 bug\ndocs: 文档（documentation）\nstyle: 格式（不影响代码运行的变动）\nrefactor: 重构（即不是新增功能，也不是修改 bug 的代码变动）\nchore: 构建过程或辅助工具的变动\nrevert: 撤销，版本回退\nperf: 性能优化\ntest：测试\nimprovement: 改进\nbuild: 打包\nci: 持续集成\n","date":"2024-11-07T15:17:11+08:00","image":"https://shuliang.asia/p/20241107/20241107_hu_567fee911f6faa6.jpg","permalink":"https://shuliang.asia/p/20241107/","title":"Git提交规范"},{"content":" 在工作中，使用netty来开发遇到了两个问题记录一下\n启动问题 如果直接注册到容器中启动，如下代码所示，那么Netty会阻塞springboot，导致服务并未完全启动。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package top.tangyh.lamp.msg.his.netty; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Component; import javax.annotation.Resource; import java.net.InetSocketAddress; /** * @author 刘书良 * @date 2024年10月12日 14:02 * @describe */ @Component @Slf4j public class NettyServerStart implements ApplicationRunner { private static String HOST = \u0026#34;127.0.0.1\u0026#34;; private static Integer PORT = 8848; @Resource private NettyServer nettyServer; @Override public void run(ApplicationArguments args) throws Exception { InetSocketAddress address = new InetSocketAddress(HOST, PORT); log.info(\u0026#34;neety服务器启动地址: \u0026#34; + HOST + \u0026#34;:\u0026#34; + PORT); nettyServer.start(address); } } 解决办法就是异步处理，在启动方法添加注解@Async，并且在Spring Boot启动类上开启异步注解，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @Override @Async public void run(ApplicationArguments args) throws Exception { InetSocketAddress address = new InetSocketAddress(HOST, PORT); log.info(\u0026#34;neety服务器启动地址: \u0026#34; + HOST + \u0026#34;:\u0026#34; + PORT); nettyServer.start(address); } ------------------------------------- @SpringBootApplication @EnableDiscoveryClient @EnableTransactionManagement @ComponentScan({ UTIL_PACKAGE, BUSINESS_PACKAGE }) @EnableFeignClients(value = { UTIL_PACKAGE, BUSINESS_PACKAGE }) @Slf4j @EnableFormValidator @EnableAsync public class MsgServerApplication { public static void main(String[] args) throws UnknownHostException { ConfigurableApplicationContext application = SpringApplication.run(MsgServerApplication.class, args); Environment env = application.getEnvironment(); log.info(\u0026#34;\\n----------------------------------------------------------\\n\\t\u0026#34; + \u0026#34;应用 \u0026#39;{}\u0026#39; 运行成功! 访问连接:\\n\\t\u0026#34; + \u0026#34;Swagger文档: \\t\\thttp://{}:{}/doc.html\\n\\t\u0026#34; + \u0026#34;数据库监控: \\t\\thttp://{}:{}/druid\\n\u0026#34; + \u0026#34;----------------------------------------------------------\u0026#34;, env.getProperty(\u0026#34;spring.application.name\u0026#34;), InetAddress.getLocalHost().getHostAddress(), env.getProperty(\u0026#34;server.port\u0026#34;, \u0026#34;8080\u0026#34;), InetAddress.getLocalHost().getHostAddress(), env.getProperty(\u0026#34;server.port\u0026#34;, \u0026#34;8080\u0026#34;) ); } } 依赖加载问题 在netty的handler类中无法注入依赖，这是因为初始化netty时，handler是new出来的没有托管给spring，所以无法依赖注入。\n解决办法是：\n1️⃣加@Component\n1 2 3 @Slf4j @Component public class NettyServerHandler extends ChannelInboundHandlerAdapter 2️⃣创建静态的handler静态对象\n1 private static NettyServerHandler nettyServerHandler; 3️⃣使用@PostConstruct初始化\n1 2 3 4 @PostConstruct public void init() { nettyServerHandler = this; } 在使用时需要在依赖注入前加上handle\n1 nettyServerHandler.icuObsvRdClient.saveXt(recordDTO); ","date":"2024-10-12T15:28:46Z","image":"https://shuliang.asia/p/20241012/20241012_hu_1f8475bcaa0a4040.jpg","permalink":"https://shuliang.asia/p/20241012/","title":"SpringBoot和Netty遇到的问题"},{"content":"MyBatis多参数传递 四种情况需要加@Param 方法有多个参数，需要使用@Param注解。 当需要给参数取别名时，需要使用@Param注解。 XML中的SQL使用了$,参数中也需要使用@Param。 动态 SQL ，如果在动态 SQL 中使用了参数作为变量，那么也需要 @Param 注解，即使你只有一个参数。 1 2 3 4 5 6 7 8 9 10 11 //mapper 接口 List\u0026lt;Device\u0026gt; getDeviceListTest(@Param(\u0026#34;deviceId\u0026#34;) String deviceId); \u0026lt;!--mybatis的xml--\u0026gt; \u0026lt;select id=\u0026#34;getDeviceListTest\u0026#34; parameterType=\u0026#34;String\u0026#34; resultType=\u0026#34;Device\u0026#34;\u0026gt; select * from t_device \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;deviceId != null and deviceId != \u0026#39;\u0026#39;\u0026#34;\u0026gt; device_id=#{deviceId} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; 为什么有时候不加@Param可以正常运行 是因为编译的问题，有时候接口通过编译，参数名称发生了变化，所以会报错找不到该参数，有时候又可以正常运行是因为idea编译采用了强制保持方法参数变量明\n参考文章，这篇解释的详细一点：https://blog.csdn.net/neusoft2016/article/details/110818507\n","date":"2024-07-28T09:40:03Z","image":"https://shuliang.asia/p/20240728/20240728_hu_e132815f365d28b2.jpg","permalink":"https://shuliang.asia/p/20240728/","title":"Mybatis参数传递"},{"content":"lombok链式编程；可以一直点set方法 1 2 3 4 5 new PatientPacsApplyPO() .setPatientIdent(patientIdent) .setHospitalNumber(hospitalNumber) .setGender(gender) .setPatientName(patientName); 要实现上述代码可以添加注解@Accessors(chain = true)\n","date":"2024-07-27T09:40:03Z","image":"https://shuliang.asia/p/20240727/20240727_hu_3ad7b533b46cd634.jpg","permalink":"https://shuliang.asia/p/20240727/","title":"lombok链式编程"},{"content":"在IDEA中配置 修改启动脚本 使用第一步得到的脚本：-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 改造启动脚本命令：\n1 2 3 nohup java \\ -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=50055 \\ -jar remote-debug-0.0.1-SNAPSHOT.jar \u0026amp; 注意在windows中用 ^ 来进行换行\n可以开始调试了 ","date":"2024-07-26T09:40:03Z","image":"https://shuliang.asia/p/20240726/20240726_hu_62abe28ae2444da9.jpg","permalink":"https://shuliang.asia/p/20240726/","title":"IDEA远程DEBUG调试"},{"content":"常用方法 ObjectUtil.isEmpty() 比较笼统的判断是否为空，不属于下面类型的仅仅判断是否为null\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static boolean isEmpty(Object obj) { if (null == obj) { return true; } if (obj instanceof CharSequence) { return StrUtil.isEmpty((CharSequence) obj); } else if (obj instanceof Map) { return MapUtil.isEmpty((Map) obj); } else if (obj instanceof Iterable) { return IterUtil.isEmpty((Iterable) obj); } else if (obj instanceof Iterator) { return IterUtil.isEmpty((Iterator) obj); } else if (ArrayUtil.isArray(obj)) { return ArrayUtil.isEmpty(obj); } return false; } Optional.ofNullable().map().orElse() v指代是gms这个列表\n1 2 3 4 5 6 List\u0026lt;AllErgenInfoResp\u0026gt; gms = wsAdpterService.getPatientGmInfo(hospitalNumber); patientTagVO.setIsGm( Optional.ofNullable(gms) .map(v -\u0026gt; !v.isEmpty()) .orElse(false) ); equal比较 使用(\u0026quot;gcx_blood\u0026quot;).equals(param.getObsvCode())而不是param.getObsvCode().equals()\n这样写可以避免空指针异常，如果param.getObsvCode()返回null。调用equal()会抛异常，而使用(\u0026quot;gcx_blood\u0026quot;).equals(null) 不会抛出异常，而是直接返回 false。\nLocalDateTime用法 格式化输出 1 2 3 4 5 6 7 8 9 10 11 package cn.hutool.core.date; /** * 格式化日期时间为yyyy-MM-dd HH:mm:ss格式 * * @param time {@link LocalDateTime} * @return 格式化后的字符串 * @since 5.3.11 */ public static String formatNormal(LocalDateTime time) { return format(time, DatePattern.NORM_DATETIME_FORMATTER); } string转LocalDateTime 1 2 3 4 5 6 7 8 9 10 11 12 /** * 将字符串转为LocalDateTime * * @param dateTimeString * @return java.time.LocalDateTime * @author 刘书良 * 2025/1/9 9:34 **/ public static LocalDateTime stringToLocalDateTime(String dateTimeString) { LocalDateTime localDateTime = LocalDateTimeUtil.parse(dateTimeString, DatePattern.NORM_DATETIME_PATTERN); return localDateTime; } 把map中的值转为list 1 2 3 4 5 6 7 8 9 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; patientMap = new HashMap\u0026lt;\u0026gt;(); patientMap.put(\u0026#34;patient1\u0026#34;, Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)); patientMap.put(\u0026#34;patient2\u0026#34;, Arrays.asList(\u0026#34;d\u0026#34;, \u0026#34;e\u0026#34;)); patientMap.put(\u0026#34;patient3\u0026#34;, Arrays.asList(\u0026#34;f\u0026#34;)); // 将所有 values 合并为一个 List List\u0026lt;String\u0026gt; combinedList = patientMap.values().stream() .flatMap(List::stream) // 将每个 List 展开为单个元素的流 .collect(Collectors.toList()); // 收集成一个 List 获取一天的开始和结束时间 1 2 LocalDateTime startOfDay = LocalDateTime.now().with(LocalTime.MIDNIGHT).minusMinutes(10); LocalDateTime endOfDay = LocalDateTime.now().with(LocalTime.MAX); ","date":"2024-07-23T17:20:49Z","image":"https://shuliang.asia/p/20240723/20240723_hu_ef01b01a0ac173a0.jpg","permalink":"https://shuliang.asia/p/20240723/","title":"Java常用工具类代码"},{"content":"final关键字 基本用法 修饰类 当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。\n报错信息： 无法继承最终的“mianshi.People”\n修饰方法 下面这段话摘自《Java编程思想》第四版第143页：\n“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“\n因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。\n注：类的private方法会隐式地被指定为final方法。\n修饰变量 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。\n深入理解final关键字 类的final变量和普通变量有什么区别 当用final作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。\n变量b被final修饰，因此会被当做编译器常量，所以在使用到b的地方会直接将变量b替换为它的值。而对于变量d的访问却需要在运行时通过链接来进行。不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化。\nint类型在Java中，若果作为类成员声明，不初始化值，会被默认初始化为0；如果作为方法的局部变量来声明，不进行初始化的话 会在编译期报错，无法通过编译。\n被final修饰的引用变量指向的对象内容可变吗 可变，final修饰对象之后，引用地址不可变。\nfinal和static static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test { public static void main(String[] args) { MyClass myClass1 = new MyClass(); MyClass myClass2 = new MyClass(); System.out.println(myClass1.i); System.out.println(myClass1.j); System.out.println(myClass2.i); System.out.println(myClass2.j); } } class MyClass { public final double i = Math.random(); public static double j = Math.random(); } 1 2 3 4 0.06299743342842823 0.6863535193008683 0.2856370702656075 0.6863535193008683 static修饰的变量,又称为类变量,也就是说这个变量是属于类的,类的所有实例共享这个变量,可以直接通过类名.变量名的方式获取,静态变量在内存中只存在一份\nmap和redis缓存区别 缓存的区别\n缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。\n使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。\n当然如果只是将少量数据保存作为缓存并且没有持久化的需求，那么完全可以用Map做缓存。\n详细的区别：\nRedis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了\nRedis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了\nRedis 可以实现分布式的缓存，Map 只能存在创建它的程序里\nRedis 单点吞吐量能达到10万级，是专业的缓存服务，Map 只是一个普通的对象\nRedis 缓存有过期机制，Map 本身无此功能\nRedis 有丰富的 API，Map 就简单太多了\nJava常量池 String常量池 当String类直接赋值时，如果常量池内存在这个字符串，则s1直接指向常量池的地址，若没有，则先在常量池内创建这个字符串对象，s1直接指向常量池这个字符串的内存地址； 当String类使用new实例对象时，首先在堆里创建这个对象，若是常量池内没这个字符串，则也创建一个，然后堆里的对象的value指向常量池内的字符串。\nclass常量池 运行时常量池 函数式编程 @RestController和@Controller区别 @RestController注解等价于@ResponseBody ＋ @Controller。@RestController和@Controller的共同点是都用来表示Spring某个类是否可以接收HTTP请求，二者区别： @RestController无法返回指定页面，而@Controller可以；前者可以直接返回数据，后者需要@ResponseBody辅助。下面详细分析。\n① 是否可以返回页面\n答：@RestController无法返回指定页面，而@Controller可以。 解析：对于Controller， 如果只是使用@RestController注解，则其方法无法返回指定页面，此时配置的视图解析器 InternalResourceViewResolver不起作用，返回的内容就是 return 里的内容。 如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。\n② 返回内容 如果需要返回JSON，XML或自定义mediaType内容到页面，@RestController自己就可以搞定，这个注解对于返回数据比较方便，因为它会自动将对象实体转换为JSON格式。而@Controller需要在对应的方法加上@ResponseBody注解。\n@Bean和@Component区别 ","date":"2024-07-11T14:15:40Z","image":"https://shuliang.asia/p/20240711/20240711_hu_b479357ea1fe579b.jpg","permalink":"https://shuliang.asia/p/20240711/","title":"咸亨国际面试"}]