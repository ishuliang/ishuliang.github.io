<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>散装知识 on 刘公子的建安百科书</title>
        <link>https://shuliang.asia/categories/knowledge/</link>
        <description>Recent content in 散装知识 on 刘公子的建安百科书</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>记录每一天</copyright>
        <lastBuildDate>Thu, 10 Jul 2025 15:56:48 +0800</lastBuildDate><atom:link href="https://shuliang.asia/categories/knowledge/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>运算符</title>
        <link>https://shuliang.asia/p/20250710/</link>
        <pubDate>Thu, 10 Jul 2025 15:56:48 +0800</pubDate>
        
        <guid>https://shuliang.asia/p/20250710/</guid>
        <description>&lt;img src="https://shuliang.asia/p/20250710/0074dbe09767e97ac5e06f43b0d1586.jpg" alt="Featured image of post 运算符" /&gt;&lt;h1 id=&#34;运算符&#34;&gt;运算符
&lt;/h1&gt;&lt;h1 id=&#34;编程语言中的运算符总览按单目双目多目分类&#34;&gt;编程语言中的运算符总览：按单目、双目、多目分类
&lt;/h1&gt;&lt;p&gt;运算符是编程语言的基础元素，用于构建表达式、实现运算和逻辑判断。本文以&lt;strong&gt;运算符的元数（即操作数个数）&lt;strong&gt;为主线，梳理常见的&lt;/strong&gt;单目（Unary）&lt;/strong&gt;、**双目（Binary）&lt;strong&gt;和&lt;/strong&gt;多目（Ternary）**运算符。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一单目运算符unary-operators&#34;&gt;一、单目运算符（Unary Operators）
&lt;/h2&gt;&lt;p&gt;单目运算符只需要一个操作数，常见如下：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;运算符&lt;/th&gt;
          &lt;th&gt;含义说明&lt;/th&gt;
          &lt;th&gt;适用示例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;正号（通常可省略）&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;+a&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;负号&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;-a&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;++&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;自增（前/后缀）&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;++a&lt;/code&gt;, &lt;code&gt;a++&lt;/code&gt; &lt;em&gt;(Java/C++)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;--&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;自减（前/后缀）&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;--a&lt;/code&gt;, &lt;code&gt;a--&lt;/code&gt; &lt;em&gt;(Java/C++)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;逻辑非&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;!flag&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;位取反&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;~a&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;not&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;布尔非&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;not a&lt;/code&gt; &lt;em&gt;(Python)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;引用/地址符（取地址）&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;&amp;amp;x&lt;/code&gt; &lt;em&gt;(C/C++)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;指针解引用&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;*p&lt;/code&gt; &lt;em&gt;(C/C++)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;++&lt;/code&gt;、&lt;code&gt;--&lt;/code&gt;在数字前后是有区别的，在前表示先计算在赋值，在后表示先赋值再计算。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;i = 100;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;op1 = i++;  // op1 = 100，先 op1 = i，然后 i = i + 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;i = 100;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;op2 = ++i;  // op2 = 101，先 i = i + 1，然后赋值 op2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;i = 100;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;op3 = i--;  // op3 = 100，先赋值 op3，然后 i = i - 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;i = 100;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;op4 = --i;  // op4 = 99，先 i = i - 1，然后赋值 op4
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;二双目运算符binary-operators&#34;&gt;二、双目运算符（Binary Operators）
&lt;/h2&gt;&lt;p&gt;双目运算符最为常见，涵盖算术、比较、逻辑等核心语义。&lt;/p&gt;
&lt;h3 id=&#34;1-算术运算符&#34;&gt;1. 算术运算符
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;运算符&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
          &lt;th&gt;示例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;加法&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;a + b&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;减法&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;a - b&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;乘法&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;a * b&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;除法&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;a / b&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;取模&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;a % b&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;**&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;幂&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;a ** b&lt;/code&gt; &lt;em&gt;(Python)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;//&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;地板除法&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;a // b&lt;/code&gt; &lt;em&gt;(Python)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-赋值运算符&#34;&gt;2. 赋值运算符
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;运算符&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;赋值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;加后赋值（&lt;code&gt;x += y&lt;/code&gt; 即 &lt;code&gt;x = x + y&lt;/code&gt;）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;-=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;减后赋值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;*=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;乘后赋值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;/=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;除后赋值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;%=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;取模赋值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;**=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;幂赋值&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;//=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;整除赋值&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;3-比较运算符&#34;&gt;3. 比较运算符
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;运算符&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;==&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;相等&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;不等&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;大于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;小于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;大于等于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;小于等于&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;is&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;对象标识相等   &lt;em&gt;(Python)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;in&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;包含判断       &lt;em&gt;(Python)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;4-位运算符&#34;&gt;4. 位运算符
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;运算符&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;位与&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;`&lt;/td&gt;
          &lt;td&gt;`&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;位异或&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;左移&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;右移（算术）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;无符号右移 &lt;em&gt;(Java)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;5-逻辑运算符&#34;&gt;5. 逻辑运算符
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;运算符&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;逻辑与（短路） &lt;em&gt;(Java/C++)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;`&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;and&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;逻辑与 &lt;em&gt;(Python)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;逻辑或 &lt;em&gt;(Python)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;三多目运算符ternary-operators&#34;&gt;三、多目运算符（Ternary Operators）
&lt;/h2&gt;&lt;p&gt;多目运算符中最经典的就是&lt;strong&gt;条件（三元）运算符&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;运算符结构&lt;/th&gt;
          &lt;th&gt;含义&lt;/th&gt;
          &lt;th&gt;示例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;a ? b : c&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;若 &lt;code&gt;a&lt;/code&gt; 为真则为 &lt;code&gt;b&lt;/code&gt;，否则为 &lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;em&gt;(Java/C/C++)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;b if a else c&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;同上逻辑&lt;/td&gt;
          &lt;td&gt;&lt;em&gt;(Python)&lt;/em&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;附录其他运算符结构组合表达式&#34;&gt;附录：其他运算符/结构（组合表达式）
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;,&lt;/code&gt; 逗号运算符（C/C++ 中存在执行顺序控制）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;、&lt;code&gt;.&lt;/code&gt; 成员访问（结构体/对象）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::&lt;/code&gt; 范围解析符（C++、Java 的静态成员访问）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结
&lt;/h2&gt;&lt;p&gt;运算符数量虽不多，但掌握其分类和语义，可以帮助我们更好地理解表达式的构造与执行逻辑。建议在使用时牢记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;括号优先，避免歧义&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;位运算性能好&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑操作符优先考虑可读性和短路效应&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>面试题记录</title>
        <link>https://shuliang.asia/p/20250709/</link>
        <pubDate>Wed, 09 Jul 2025 14:56:48 +0800</pubDate>
        
        <guid>https://shuliang.asia/p/20250709/</guid>
        <description>&lt;img src="https://shuliang.asia/p/20250709/f9ffa0e132b8dd7bf0c3c407f27275d.jpg" alt="Featured image of post 面试题记录" /&gt;&lt;h1 id=&#34;面试题&#34;&gt;面试题
&lt;/h1&gt;&lt;h2 id=&#34;redis是什么&#34;&gt;redis是什么
&lt;/h2&gt;&lt;p&gt;Redis 是完全开源免费的， 遵守&lt;code&gt;BSD&lt;/code&gt;协议， 是一个高性能的&lt;code&gt;key-value&lt;/code&gt;数据库。&lt;/p&gt;
&lt;p&gt;Redis 与其他&lt;code&gt;key - value&lt;/code&gt;缓存产品有以下三个特点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/p&gt;
&lt;p&gt;Redis 不仅仅支持简单的&lt;code&gt;key-value&lt;/code&gt;类型的数据， 同时还提供&lt;code&gt;list&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;，&lt;code&gt;zset&lt;/code&gt;，&lt;code&gt;hash&lt;/code&gt;等数据结构的存
储。&lt;/p&gt;
&lt;p&gt;Redis 支持数据的备份， 即&lt;code&gt;master-slave&lt;/code&gt;模式的数据备份。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Redis 优势:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;性能极高: Redis 能读的速度是 110000 次/s,写的速度是 81000 次/s 。&lt;/p&gt;
&lt;p&gt;丰富的数据类型 : Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及Ordered Sets 数据类型操
作。&lt;/p&gt;
&lt;p&gt;原子: Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子
性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。&lt;/p&gt;
&lt;p&gt;丰富的特性: Redis 还支持 publish/subscribe, 通知, key 过期等等特性。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Redis 与其他 key-value 存储的不同：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路
径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明， 无需进行额外的抽象。&lt;/p&gt;
&lt;p&gt;Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存， 因为
数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，
在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他
们是紧凑的以追加的方式产生的， 因为他们并不需要进行随机访问。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;redis数据双写&#34;&gt;redis数据双写
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://shuliang.asia/p/20250709/image-20250709103958047.png&#34;
	width=&#34;1057&#34;
	height=&#34;3212&#34;
	srcset=&#34;https://shuliang.asia/p/20250709/image-20250709103958047_hu_37f812a6cf5ee893.png 480w, https://shuliang.asia/p/20250709/image-20250709103958047_hu_74955d0ac57f6b3c.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250709103958047&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;32&#34;
		data-flex-basis=&#34;78px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;redis-的数据类型&#34;&gt;Redis 的数据类型
&lt;/h2&gt;&lt;p&gt;Redis 支持五种数据类型： string（ 字符串），hash（ 哈希）， list（ 列表）， set（ 集合） 及
sorted set（有序集合）。&lt;/p&gt;
&lt;h2 id=&#34;redis-的持久化机制&#34;&gt;Redis 的持久化机制
&lt;/h2&gt;&lt;p&gt;Redis 提供两种持久化机制 RDB 和 AOF 机制:
RDB（Redis DataBase）持久化方式： 是指用数据集快照的方式（半持久化模式）记录 redis 数据库的所
有键值对,在某个时间点将数据写入一个临时文件， 持久化结束后， 用这个临时文件替换上次持久化的
文件， 达到数据恢复。
优点：
1、只有一个文件 dump.rdb， 方便持久化。&lt;/p&gt;
&lt;p&gt;2、容灾性好， 一个文件可以保存到安全的磁盘。&lt;/p&gt;
&lt;p&gt;3、性能最大化， fork 子进程来完成写操作， 让主进程继续处理命令， 所以是 IO 最大化。使用单独子
进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能&lt;/p&gt;
&lt;p&gt;4、相对于数据集大时， 比AOF 的启动效率更高。
缺点:
1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障， 会发生数据丢
失。所以这种方式更适合数据要求不严谨的时候&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shuliang.asia/p/20250709/image-20250709102528490.png&#34;
	width=&#34;943&#34;
	height=&#34;552&#34;
	srcset=&#34;https://shuliang.asia/p/20250709/image-20250709102528490_hu_8a7151daca4454cd.png 480w, https://shuliang.asia/p/20250709/image-20250709102528490_hu_b1e13f58f0af79b2.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250709102528490&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;170&#34;
		data-flex-basis=&#34;410px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;AOF（Append-only file）持久化方式： 是指所有的命令行记录以 redis 命令请求协议的格式（完全持久化存储）保存为 aof 文件。
优点：
1、数据安全， aof 持久化可以配置 appendfsync 属性， 有 always， 每进行一次命令操作就记录到aof 文件中一次。
2、通过 append 模式写文件， 即使中途服务器宕机， 可以通过 redis-check-aof 工具解决数据一致性问题。
3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（ 文件过大时会对命令进行合并重写）， 可以删除其中的某些命令（ 比如误操作的 flushall）)
缺点：
1、AOF 文件比 RDB 文件大， 且恢复速度慢。
2、数据集大的时候， 比 rdb 启动效率低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shuliang.asia/p/20250709/image-20250709102642996.png&#34;
	width=&#34;806&#34;
	height=&#34;586&#34;
	srcset=&#34;https://shuliang.asia/p/20250709/image-20250709102642996_hu_fdb668c9c204581b.png 480w, https://shuliang.asia/p/20250709/image-20250709102642996_hu_7db8da650fc131d0.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20250709102642996&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;330px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;redis过期处理&#34;&gt;redis过期处理
&lt;/h2&gt;&lt;p&gt;1、定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。
2、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是 否过期， 如果过期的话， 就删除该键;如果没有过期， 就返回该键。
3、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至 于要删除多少过期键， 以及要检查多少个数据库， 则由算法决定。&lt;/p&gt;
&lt;h2 id=&#34;redis事务处理&#34;&gt;redis事务处理
&lt;/h2&gt;&lt;p&gt;通过 MULTI、EXEC、WATCH 等命令来实现事务功能。支持将多个命令请求打包，按顺序一次性执行，执行期间不会中断处理其他客户端请求，具有原子性（Atomicity)、一致性(Consistency)和隔离性（Isolation），且在特定持久模式下具备持久性（Durability）&lt;/p&gt;
&lt;h2 id=&#34;redis为什么这么快&#34;&gt;Redis为什么这么快
&lt;/h2&gt;&lt;p&gt;1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；&lt;/p&gt;
&lt;p&gt;2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；&lt;/p&gt;
&lt;p&gt;3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；&lt;/p&gt;
&lt;p&gt;4、使用多路 I/O 复用模型，非阻塞 IO；&lt;/p&gt;
&lt;p&gt;5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；&lt;/p&gt;
&lt;p&gt;elasticsearch深度分页,怎么解决&lt;/p&gt;
&lt;p&gt;es适合搜索+日志，使用范围很小&lt;/p&gt;
&lt;p&gt;购物车用Redis,redis适合热点数据：频繁访问但不频繁修改 的数据&lt;/p&gt;
&lt;p&gt;redis的数据类型时key-value  类型的&lt;/p&gt;
&lt;p&gt;如果存购物车数据，需要用其中的哈希类型和zset类型&lt;/p&gt;
&lt;p&gt;redis的数据类型中字符串适合存验证码&lt;/p&gt;
&lt;p&gt;cacahe.set(key,value)适用于字符串&lt;/p&gt;
&lt;p&gt;订单存mysql&lt;/p&gt;
&lt;p&gt;在Vue中用try&amp;hellip; catch&amp;hellip;时，只要HTTP状态码不是200就会进入catch，此时获取catch报错的状态码可以用error.response.status&lt;/p&gt;
&lt;p&gt;bytes字节&lt;/p&gt;
&lt;p&gt;encode 编码 将字符串转为字节，decode 解码 及那个字节转为字符串&lt;/p&gt;
&lt;p&gt;json.loads 序列化 把json字符串转为字典&lt;/p&gt;
&lt;p&gt;json.dumps 反序列化&lt;/p&gt;
</description>
        </item>
        <item>
        <title>正则表达式学习</title>
        <link>https://shuliang.asia/p/20250623/</link>
        <pubDate>Mon, 23 Jun 2025 16:39:04 +0800</pubDate>
        
        <guid>https://shuliang.asia/p/20250623/</guid>
        <description>&lt;img src="https://shuliang.asia/p/20250623/20250623.jpg" alt="Featured image of post 正则表达式学习" /&gt;&lt;h1 id=&#34;正则表达式&#34;&gt;正则表达式
&lt;/h1&gt;&lt;h2 id=&#34;基本匹配&#34;&gt;基本匹配
&lt;/h2&gt;&lt;p&gt;我们想要查找的字符或单词可以直接输入，就像搜索一样。例如，要找出文本中的 curious 一词，只需输入同样的内容。&lt;/p&gt;
&lt;h3 id=&#34;任何字符&#34;&gt;任何字符
&lt;/h3&gt;&lt;p&gt;点&lt;code&gt;.&lt;/code&gt;：允许匹配任何字符，包括特殊字符和空格&lt;/p&gt;
&lt;h3 id=&#34;字符集abc&#34;&gt;字符集&lt;code&gt;[abc]&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;如果一个词中的字符可以是各种字符，我们就将所有的可选字符写进中括号 [] 中。例如，为了查找文本中的所有单词，我们需要编写表达式，在 [] 中相邻地输入字符 a、e、i、o、u。&lt;/p&gt;
&lt;h3 id=&#34;否定字符集abc&#34;&gt;否定字符集&lt;code&gt;[^abc]&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;为了查找下方文本的所有单词（&lt;code&gt;ber&lt;/code&gt; 和&lt;code&gt;bor&lt;/code&gt; 除外），请在 [] 中的 ^ 后面并排输入 e 和 o。&lt;/p&gt;
&lt;h3 id=&#34;字母范围a-z&#34;&gt;字母范围&lt;code&gt;[a-z]&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;为了查找指定范围的字母，我们需要将起始字母和结束字母写进 &lt;code&gt;[] &lt;/code&gt;中，中间用连字符&lt;code&gt;-&lt;/code&gt;分隔。它区分大小写。请编写表达式，匹配&lt;code&gt;e&lt;/code&gt;和&lt;code&gt;o&lt;/code&gt;之间所有的小写字母，包括它们本身。&lt;/p&gt;
&lt;h3 id=&#34;数字范围0-9&#34;&gt;数字范围&lt;code&gt;[0-9]&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;为了查找指定范围的数字，我们需要在&lt;code&gt;[]&lt;/code&gt;中输入起始和结束数字，中间用连字符&lt;code&gt;-&lt;/code&gt;分隔。请编写表达式，匹配&lt;code&gt;3&lt;/code&gt;到&lt;code&gt;6&lt;/code&gt;之间的所有数字，包括它们本身。&lt;/p&gt;
&lt;h2 id=&#34;重复&#34;&gt;重复
&lt;/h2&gt;&lt;p&gt;一些特殊字符用来指定一个字符在文本中重复的次数。它们分别是加号&lt;code&gt;+&lt;/code&gt;、星号&lt;code&gt;*&lt;/code&gt;和问号&lt;code&gt;?&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;星号&#34;&gt;星号&lt;code&gt;*&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;在字符后面加上&lt;code&gt;*&lt;/code&gt;，表示一个字符没有或者存在多次。&lt;/p&gt;
&lt;h3 id=&#34;加号&#34;&gt;加号&lt;code&gt;+&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;在字符后面加上&lt;code&gt;+&lt;/code&gt;，表示一个字符出现一次或者多次&lt;/p&gt;
&lt;h3 id=&#34;问号&#34;&gt;问号&lt;code&gt;?&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;在字符后面加上&lt;code&gt;+&lt;/code&gt;，表示一个字符可选，出现一次或者一次都没有&lt;/p&gt;
&lt;h3 id=&#34;大括号-1&#34;&gt;大括号-1
&lt;/h3&gt;&lt;p&gt;用&lt;code&gt;{n}&lt;/code&gt;编写表达式，匹配文本中位数为n的字符。&lt;/p&gt;
&lt;h3 id=&#34;大括号-2&#34;&gt;大括号-2
&lt;/h3&gt;&lt;p&gt;用&lt;code&gt;{n,}&lt;/code&gt;编写表达式，匹配文本中位数至少为n的字符。&lt;/p&gt;
&lt;h3 id=&#34;大括号-3&#34;&gt;大括号-3
&lt;/h3&gt;&lt;p&gt;用&lt;code&gt;{n,m}&lt;/code&gt;编写表达式，匹配文本中位数为n至m的字符。&lt;/p&gt;
&lt;h2 id=&#34;分组&#34;&gt;分组
&lt;/h2&gt;&lt;p&gt;我们可以对一个表达式进行分组，并用这些分组来引用或执行一些规则。&lt;/p&gt;
&lt;h3 id=&#34;括号分组&#34;&gt;括号&lt;code&gt;()&lt;/code&gt;分组
&lt;/h3&gt;&lt;p&gt;使用括号包裹字符，实现分组&lt;/p&gt;
&lt;h3 id=&#34;引用组&#34;&gt;引用组
&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;\1&lt;/code&gt;来避免重复书写，这里1表示分组顺序。&lt;/p&gt;
&lt;h3 id=&#34;非捕获分组&#34;&gt;非捕获分组
&lt;/h3&gt;&lt;p&gt;使用括号&lt;code&gt;(?:)&lt;/code&gt;分组，确保它不会被引用捕获。&lt;/p&gt;
&lt;h2 id=&#34;特殊字符&#34;&gt;特殊字符
&lt;/h2&gt;&lt;h3 id=&#34;竖线&#34;&gt;竖线&lt;code&gt;|&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;竖线允许一个表达式包含多个不同的分支。所有分支用&lt;code&gt;|&lt;/code&gt;分隔。和在字符层面上运作的字符集&lt;code&gt;[abc]&lt;/code&gt;不同，分支在表达式层面上运作。&lt;/p&gt;
&lt;h3 id=&#34;转义字符&#34;&gt;转义字符&lt;code&gt;\&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;在书写正则表达式时，我们会用到&lt;code&gt;{}[]\/+*.$^|?&lt;/code&gt;这些特殊字符。为了匹配这些特殊字符本身，我们需要使用&lt;code&gt;\&lt;/code&gt;进行转义。&lt;/p&gt;
&lt;h3 id=&#34;插入符&#34;&gt;插入符&lt;code&gt;^&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;匹配字符串的开始。如果仅仅需要查找行首字符，就在表达式前面添加&lt;code&gt;^&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;美元符号&#34;&gt;美元符号&lt;code&gt;$&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;匹配字符串的结束。加在字符的后面。&lt;/p&gt;
&lt;h2 id=&#34;单词字符&#34;&gt;单词字符
&lt;/h2&gt;&lt;h3 id=&#34;w&#34;&gt;&lt;code&gt;\w&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;匹配字母、数字、下划线。&lt;/p&gt;
&lt;h3 id=&#34;w-1&#34;&gt;&lt;code&gt;\W&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;匹配除字母、数字、下划线之外的字符。&lt;/p&gt;
&lt;h3 id=&#34;数字符d&#34;&gt;数字符&lt;code&gt;\d&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;仅匹配数字。&lt;/p&gt;
&lt;h3 id=&#34;非数字符d&#34;&gt;非数字符&lt;code&gt;\D&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;匹配除数字外的所有字符。&lt;/p&gt;
&lt;h3 id=&#34;空白符s&#34;&gt;空白符&lt;code&gt;\s&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;仅匹配空白字符。&lt;/p&gt;
&lt;h3 id=&#34;非空白符s&#34;&gt;非空白符&lt;code&gt;\S&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;匹配除空白符之外的字符。&lt;/p&gt;
&lt;h2 id=&#34;零宽断言&#34;&gt;零宽断言
&lt;/h2&gt;&lt;p&gt;如果我们希望正在写的词语出现在另一个词语之前或之后，我们需要使用零宽断言。&lt;/p&gt;
&lt;h3 id=&#34;正向先行断言&#34;&gt;正向先行断言&lt;code&gt;(?=)&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;为了匹配后面有指定字符的值，我们可以在=后面写。放在字符后&lt;/p&gt;
&lt;h3 id=&#34;负向先行断言&#34;&gt;负向先行断言&lt;code&gt;(?!)&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;为了匹配后面没有有指定字符的值，我们可以在!后面写。&lt;/p&gt;
&lt;h3 id=&#34;正向后行断言&#34;&gt;正向后行断言&lt;code&gt;(?&amp;lt;=)&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;为了匹配前面有指定字符的值，我们可以在=后面写。放在字符前&lt;/p&gt;
&lt;h3 id=&#34;负向后行断言&#34;&gt;负向后行断言&lt;code&gt;(?&amp;lt;!)&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;为了匹配前面没有指定字符的值，我们可以在!后面写。&lt;/p&gt;
&lt;h2 id=&#34;标志&#34;&gt;标志
&lt;/h2&gt;&lt;p&gt;标志改变表达式的输出。这就是标志也称为&lt;code&gt;修饰符&lt;/code&gt;的原因。标志决定表达式是否将文本视作单独的行处理，是否区分大小写，或者是否查找所有匹配项。&lt;/p&gt;
&lt;h3 id=&#34;全局标志g&#34;&gt;全局标志&lt;code&gt;g&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;表达式以&lt;code&gt;//&lt;/code&gt;包裹，在后面加g表示匹配全局符合要求的，否则只有一个匹配项。&lt;/p&gt;
&lt;h3 id=&#34;多行标志m&#34;&gt;多行标志&lt;code&gt;m&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;正则表达式将所有文本视作一行。但如果我们使用了多行标志，它就会单独处理每一行。&lt;/p&gt;
&lt;h3 id=&#34;忽略大小写标志i&#34;&gt;忽略大小写标志&lt;code&gt;i&lt;/code&gt;
&lt;/h3&gt;&lt;p&gt;为了使我们编写的表达式不再大小写敏感，我们必须启用&lt;code&gt;不区分大小写&lt;/code&gt;标志。&lt;/p&gt;
&lt;h3 id=&#34;贪婪匹配&#34;&gt;贪婪匹配
&lt;/h3&gt;&lt;p&gt;正则表达式默认执行贪婪匹配。这意味着匹配内容会尽可能长。&lt;/p&gt;
&lt;h3 id=&#34;懒惰匹配&#34;&gt;懒惰匹配
&lt;/h3&gt;&lt;p&gt;与贪婪匹配不同，懒惰匹配在第一次匹配时停止。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>咸亨国际面试</title>
        <link>https://shuliang.asia/p/20240711/</link>
        <pubDate>Thu, 11 Jul 2024 14:15:40 +0000</pubDate>
        
        <guid>https://shuliang.asia/p/20240711/</guid>
        <description>&lt;img src="https://shuliang.asia/p/20240711/20240711.jpg" alt="Featured image of post 咸亨国际面试" /&gt;&lt;h2 id=&#34;final关键字&#34;&gt;final关键字
&lt;/h2&gt;&lt;h3 id=&#34;基本用法&#34;&gt;基本用法
&lt;/h3&gt;&lt;h4 id=&#34;修饰类&#34;&gt;修饰类
&lt;/h4&gt;&lt;p&gt;当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shuliang.asia/images/final%e7%b1%bb%e6%97%a0%e6%b3%95%e7%bb%a7%e6%89%bf.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;报错信息： 无法继承最终的“mianshi.People”&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;修饰方法&#34;&gt;修饰方法
&lt;/h4&gt;&lt;p&gt;下面这段话摘自《Java编程思想》第四版第143页：&lt;/p&gt;
&lt;p&gt;　　“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“&lt;/p&gt;
&lt;p&gt;　　因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为final的。&lt;/p&gt;
&lt;p&gt;注：&lt;strong&gt;类的private方法会隐式地被指定为final方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;修饰变量&#34;&gt;修饰变量
&lt;/h4&gt;&lt;p&gt;对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。&lt;/p&gt;
&lt;h3 id=&#34;深入理解final关键字&#34;&gt;深入理解final关键字
&lt;/h3&gt;&lt;h4 id=&#34;类的final变量和普通变量有什么区别&#34;&gt;类的final变量和普通变量有什么区别
&lt;/h4&gt;&lt;p&gt;当用final作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://shuliang.asia/images/final%e5%8f%98%e9%87%8f%e6%97%a0%e6%b3%95%e4%bf%ae%e6%94%b9.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;变量b被final修饰，因此会被当做编译器常量，所以在使用到b的地方会直接将变量b替换为它的值。而对于变量d的访问却需要在运行时通过链接来进行。不过要注意，只有在编译期间能确切知道final变量值的情况下，编译器才会进行这样的优化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;int类型在Java中，若果作为类成员声明，不初始化值，会被默认初始化为0；如果作为方法的局部变量来声明，不进行初始化的话 会在编译期报错，无法通过编译。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;被final修饰的引用变量指向的对象内容可变吗&#34;&gt;被final修饰的引用变量指向的对象内容可变吗
&lt;/h4&gt;&lt;p&gt;可变，final修饰对象之后，引用地址不可变。&lt;/p&gt;
&lt;h4 id=&#34;final和static&#34;&gt;final和static
&lt;/h4&gt;&lt;p&gt;static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Test&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myClass1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myClass2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myClass1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myClass1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myClass2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myClass2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MyClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.06299743342842823
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.6863535193008683
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.2856370702656075
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;0.6863535193008683
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;static修饰的变量,又称为类变量,也就是说这个变量是属于类的,类的所有实例共享这个变量,可以直接通过类名.变量名的方式获取,静态变量在内存中只存在一份&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;map和redis缓存区别&#34;&gt;map和redis缓存区别
&lt;/h2&gt;&lt;p&gt;缓存的区别&lt;/p&gt;
&lt;p&gt;缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。&lt;/p&gt;
&lt;p&gt;使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持redis或memcached服务的高可用，整个程序架构上较为复杂。&lt;/p&gt;
&lt;p&gt;当然如果只是将少量数据保存作为缓存并且没有持久化的需求，那么完全可以用Map做缓存。&lt;/p&gt;
&lt;p&gt;详细的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 单点吞吐量能达到10万级，是专业的缓存服务，Map 只是一个普通的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 缓存有过期机制，Map 本身无此功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 有丰富的 API，Map 就简单太多了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;java常量池&#34;&gt;Java常量池
&lt;/h2&gt;&lt;h3 id=&#34;string常量池&#34;&gt;String常量池
&lt;/h3&gt;&lt;p&gt;当String类直接赋值时，如果常量池内存在这个字符串，则s1直接指向常量池的地址，若没有，则先在常量池内创建这个字符串对象，s1直接指向常量池这个字符串的内存地址； 当String类使用new实例对象时，首先在堆里创建这个对象，若是常量池内没这个字符串，则也创建一个，然后堆里的对象的value指向常量池内的字符串。&lt;/p&gt;
&lt;h3 id=&#34;class常量池&#34;&gt;class常量池
&lt;/h3&gt;&lt;h3 id=&#34;运行时常量池&#34;&gt;运行时常量池
&lt;/h3&gt;&lt;h2 id=&#34;函数式编程&#34;&gt;函数式编程
&lt;/h2&gt;&lt;h2 id=&#34;restcontroller和controller区别&#34;&gt;@RestController和@Controller区别
&lt;/h2&gt;&lt;p&gt;@RestController注解等价于@ResponseBody ＋ @Controller。@RestController和@Controller的共同点是都用来表示Spring某个类是否可以接收HTTP请求，二者区别： @RestController无法返回指定页面，而@Controller可以；前者可以直接返回数据，后者需要@ResponseBody辅助。下面详细分析。&lt;/p&gt;
&lt;p&gt;① 是否可以返回页面&lt;/p&gt;
&lt;p&gt;　　答：@RestController无法返回指定页面，而@Controller可以。 　　解析：对于Controller， 如果只是使用@RestController注解，则其方法无法返回指定页面，此时配置的视图解析器 InternalResourceViewResolver不起作用，返回的内容就是 return 里的内容。 如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。&lt;/p&gt;
&lt;p&gt;② 返回内容 　　如果需要返回JSON，XML或自定义mediaType内容到页面，@RestController自己就可以搞定，这个注解对于返回数据比较方便，因为它会自动将对象实体转换为JSON格式。而@Controller需要在对应的方法加上@ResponseBody注解。&lt;/p&gt;
&lt;h2 id=&#34;bean和component区别&#34;&gt;@Bean和@Component区别
&lt;/h2&gt;</description>
        </item>
        
    </channel>
</rss>
